// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eval_rules.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createEvalRule = `-- name: CreateEvalRule :one
INSERT INTO eval_rules (
  suite_id,
  eval_type,
  min_score,
  max_score,
  weight,
  hard_fail,
  params
) VALUES (
  $1,        -- suite_id
  $2,        -- eval_type
  $3,        -- min_score
  $4,        -- max_score
  $5,        -- weight
  $6,        -- hard_fail
  $7         -- params :: jsonb
)
RETURNING id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
`

type CreateEvalRuleParams struct {
	SuiteID  uuid.UUID       `json:"suite_id"`
	EvalType string          `json:"eval_type"`
	MinScore sql.NullFloat64 `json:"min_score"`
	MaxScore sql.NullFloat64 `json:"max_score"`
	Weight   float32         `json:"weight"`
	HardFail bool            `json:"hard_fail"`
	Params   json.RawMessage `json:"params"`
}

func (q *Queries) CreateEvalRule(ctx context.Context, arg CreateEvalRuleParams) (EvalRule, error) {
	row := q.db.QueryRowContext(ctx, createEvalRule,
		arg.SuiteID,
		arg.EvalType,
		arg.MinScore,
		arg.MaxScore,
		arg.Weight,
		arg.HardFail,
		arg.Params,
	)
	var i EvalRule
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.EvalType,
		&i.MinScore,
		&i.MaxScore,
		&i.Weight,
		&i.HardFail,
		&i.Params,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEvalRule = `-- name: DeleteEvalRule :exec
DELETE FROM eval_rules
WHERE id = $1
`

func (q *Queries) DeleteEvalRule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvalRule, id)
	return err
}

const deleteEvalRulesBySuite = `-- name: DeleteEvalRulesBySuite :exec
DELETE FROM eval_rules
WHERE suite_id = $1
`

func (q *Queries) DeleteEvalRulesBySuite(ctx context.Context, suiteID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvalRulesBySuite, suiteID)
	return err
}

const getEvalRule = `-- name: GetEvalRule :one
SELECT id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
FROM eval_rules
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEvalRule(ctx context.Context, id uuid.UUID) (EvalRule, error) {
	row := q.db.QueryRowContext(ctx, getEvalRule, id)
	var i EvalRule
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.EvalType,
		&i.MinScore,
		&i.MaxScore,
		&i.Weight,
		&i.HardFail,
		&i.Params,
		&i.CreatedAt,
	)
	return i, err
}

const getEvalRuleBySuiteAndType = `-- name: GetEvalRuleBySuiteAndType :one
SELECT id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
FROM eval_rules
WHERE suite_id = $1
  AND eval_type = $2
LIMIT 1
`

type GetEvalRuleBySuiteAndTypeParams struct {
	SuiteID  uuid.UUID `json:"suite_id"`
	EvalType string    `json:"eval_type"`
}

func (q *Queries) GetEvalRuleBySuiteAndType(ctx context.Context, arg GetEvalRuleBySuiteAndTypeParams) (EvalRule, error) {
	row := q.db.QueryRowContext(ctx, getEvalRuleBySuiteAndType, arg.SuiteID, arg.EvalType)
	var i EvalRule
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.EvalType,
		&i.MinScore,
		&i.MaxScore,
		&i.Weight,
		&i.HardFail,
		&i.Params,
		&i.CreatedAt,
	)
	return i, err
}

const listEvalRulesByEvalType = `-- name: ListEvalRulesByEvalType :many
SELECT id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
FROM eval_rules
WHERE eval_type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEvalRulesByEvalType(ctx context.Context, evalType string) ([]EvalRule, error) {
	rows, err := q.db.QueryContext(ctx, listEvalRulesByEvalType, evalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalRule
	for rows.Next() {
		var i EvalRule
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.EvalType,
			&i.MinScore,
			&i.MaxScore,
			&i.Weight,
			&i.HardFail,
			&i.Params,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvalRulesBySuite = `-- name: ListEvalRulesBySuite :many
SELECT id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
FROM eval_rules
WHERE suite_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListEvalRulesBySuite(ctx context.Context, suiteID uuid.UUID) ([]EvalRule, error) {
	rows, err := q.db.QueryContext(ctx, listEvalRulesBySuite, suiteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalRule
	for rows.Next() {
		var i EvalRule
		if err := rows.Scan(
			&i.ID,
			&i.SuiteID,
			&i.EvalType,
			&i.MinScore,
			&i.MaxScore,
			&i.Weight,
			&i.HardFail,
			&i.Params,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvalRule = `-- name: UpdateEvalRule :one
UPDATE eval_rules
SET
  min_score = $2,
  max_score = $3,
  weight = $4,
  hard_fail = $5,
  params = $6
WHERE id = $1
RETURNING id, suite_id, eval_type, min_score, max_score, weight, hard_fail, params, created_at
`

type UpdateEvalRuleParams struct {
	ID       uuid.UUID       `json:"id"`
	MinScore sql.NullFloat64 `json:"min_score"`
	MaxScore sql.NullFloat64 `json:"max_score"`
	Weight   float32         `json:"weight"`
	HardFail bool            `json:"hard_fail"`
	Params   json.RawMessage `json:"params"`
}

func (q *Queries) UpdateEvalRule(ctx context.Context, arg UpdateEvalRuleParams) (EvalRule, error) {
	row := q.db.QueryRowContext(ctx, updateEvalRule,
		arg.ID,
		arg.MinScore,
		arg.MaxScore,
		arg.Weight,
		arg.HardFail,
		arg.Params,
	)
	var i EvalRule
	err := row.Scan(
		&i.ID,
		&i.SuiteID,
		&i.EvalType,
		&i.MinScore,
		&i.MaxScore,
		&i.Weight,
		&i.HardFail,
		&i.Params,
		&i.CreatedAt,
	)
	return i, err
}
