// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eval_results.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const deleteEvalResultsByRun = `-- name: DeleteEvalResultsByRun :exec
DELETE FROM eval_results
WHERE eval_run_id = $1
`

func (q *Queries) DeleteEvalResultsByRun(ctx context.Context, evalRunID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvalResultsByRun, evalRunID)
	return err
}

const getEvalResultByID = `-- name: GetEvalResultByID :one
SELECT id, eval_run_id, pass, score, details, created_at, rule_id
FROM eval_results
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEvalResultByID(ctx context.Context, id uuid.UUID) (EvalResult, error) {
	row := q.db.QueryRowContext(ctx, getEvalResultByID, id)
	var i EvalResult
	err := row.Scan(
		&i.ID,
		&i.EvalRunID,
		&i.Pass,
		&i.Score,
		&i.Details,
		&i.CreatedAt,
		&i.RuleID,
	)
	return i, err
}

const listEvalResultsByRule = `-- name: ListEvalResultsByRule :many
SELECT id, eval_run_id, pass, score, details, created_at, rule_id
FROM eval_results
WHERE rule_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListEvalResultsByRule(ctx context.Context, ruleID uuid.UUID) ([]EvalResult, error) {
	rows, err := q.db.QueryContext(ctx, listEvalResultsByRule, ruleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalResult
	for rows.Next() {
		var i EvalResult
		if err := rows.Scan(
			&i.ID,
			&i.EvalRunID,
			&i.Pass,
			&i.Score,
			&i.Details,
			&i.CreatedAt,
			&i.RuleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvalResultsByRun = `-- name: ListEvalResultsByRun :many
SELECT id, eval_run_id, pass, score, details, created_at, rule_id
FROM eval_results
WHERE eval_run_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListEvalResultsByRun(ctx context.Context, evalRunID uuid.UUID) ([]EvalResult, error) {
	rows, err := q.db.QueryContext(ctx, listEvalResultsByRun, evalRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalResult
	for rows.Next() {
		var i EvalResult
		if err := rows.Scan(
			&i.ID,
			&i.EvalRunID,
			&i.Pass,
			&i.Score,
			&i.Details,
			&i.CreatedAt,
			&i.RuleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEvalResult = `-- name: UpsertEvalResult :one
INSERT INTO eval_results (
  eval_run_id,
  rule_id,
  pass,
  score,
  details
) VALUES (
  $1,        -- eval_run_id
  $2,        -- rule_id
  $3,        -- pass
  $4,        -- score
  $5         -- details :: jsonb
)
ON CONFLICT (eval_run_id, rule_id)
DO UPDATE SET
  pass = EXCLUDED.pass,
  score = EXCLUDED.score,
  details = EXCLUDED.details
RETURNING id, eval_run_id, pass, score, details, created_at, rule_id
`

type UpsertEvalResultParams struct {
	EvalRunID uuid.UUID       `json:"eval_run_id"`
	RuleID    uuid.UUID       `json:"rule_id"`
	Pass      bool            `json:"pass"`
	Score     sql.NullFloat64 `json:"score"`
	Details   json.RawMessage `json:"details"`
}

func (q *Queries) UpsertEvalResult(ctx context.Context, arg UpsertEvalResultParams) (EvalResult, error) {
	row := q.db.QueryRowContext(ctx, upsertEvalResult,
		arg.EvalRunID,
		arg.RuleID,
		arg.Pass,
		arg.Score,
		arg.Details,
	)
	var i EvalResult
	err := row.Scan(
		&i.ID,
		&i.EvalRunID,
		&i.Pass,
		&i.Score,
		&i.Details,
		&i.CreatedAt,
		&i.RuleID,
	)
	return i, err
}
