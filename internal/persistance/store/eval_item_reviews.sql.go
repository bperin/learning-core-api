// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eval_item_reviews.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createEvalItemReview = `-- name: CreateEvalItemReview :one
INSERT INTO eval_item_reviews (
  eval_item_id, reviewer_id, verdict, reasons, comments
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at
`

type CreateEvalItemReviewParams struct {
	EvalItemID uuid.UUID      `json:"eval_item_id"`
	ReviewerID uuid.UUID      `json:"reviewer_id"`
	Verdict    ReviewVerdict  `json:"verdict"`
	Reasons    []string       `json:"reasons"`
	Comments   sql.NullString `json:"comments"`
}

func (q *Queries) CreateEvalItemReview(ctx context.Context, arg CreateEvalItemReviewParams) (EvalItemReview, error) {
	row := q.db.QueryRowContext(ctx, createEvalItemReview,
		arg.EvalItemID,
		arg.ReviewerID,
		arg.Verdict,
		pq.Array(arg.Reasons),
		arg.Comments,
	)
	var i EvalItemReview
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.ReviewerID,
		&i.Verdict,
		pq.Array(&i.Reasons),
		&i.Comments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEvalItemReview = `-- name: GetEvalItemReview :one
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEvalItemReview(ctx context.Context, id uuid.UUID) (EvalItemReview, error) {
	row := q.db.QueryRowContext(ctx, getEvalItemReview, id)
	var i EvalItemReview
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.ReviewerID,
		&i.Verdict,
		pq.Array(&i.Reasons),
		&i.Comments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingReviewsForEval = `-- name: GetPendingReviewsForEval :many
SELECT DISTINCT ei.id, ei.eval_id, ei.prompt, ei.options, ei.correct_idx, ei.hint, ei.explanation, ei.metadata, ei.created_at, ei.updated_at, ei.grounding_metadata, ei.source_document_id
FROM eval_items ei
LEFT JOIN eval_item_reviews eir ON ei.id = eir.eval_item_id
WHERE ei.eval_id = $1
AND (eir.id IS NULL OR eir.verdict = 'NEEDS_REVISION')
ORDER BY ei.id ASC
`

func (q *Queries) GetPendingReviewsForEval(ctx context.Context, evalID uuid.UUID) ([]EvalItem, error) {
	rows, err := q.db.QueryContext(ctx, getPendingReviewsForEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItem
	for rows.Next() {
		var i EvalItem
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GroundingMetadata,
			&i.SourceDocumentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewStatsForEvalItem = `-- name: GetReviewStatsForEvalItem :one
SELECT 
  COUNT(*) as total_reviews,
  COUNT(CASE WHEN verdict = 'APPROVED' THEN 1 END) as approved_count,
  COUNT(CASE WHEN verdict = 'REJECTED' THEN 1 END) as rejected_count,
  COUNT(CASE WHEN verdict = 'NEEDS_REVISION' THEN 1 END) as needs_revision_count,
  CASE 
    WHEN COUNT(*) > 0 THEN 
      ROUND(COUNT(CASE WHEN verdict = 'APPROVED' THEN 1 END)::numeric / COUNT(*)::numeric * 100, 2)
    ELSE 0 
  END as approval_rate
FROM eval_item_reviews 
WHERE eval_item_id = $1
`

type GetReviewStatsForEvalItemRow struct {
	TotalReviews       int64 `json:"total_reviews"`
	ApprovedCount      int64 `json:"approved_count"`
	RejectedCount      int64 `json:"rejected_count"`
	NeedsRevisionCount int64 `json:"needs_revision_count"`
	ApprovalRate       int32 `json:"approval_rate"`
}

func (q *Queries) GetReviewStatsForEvalItem(ctx context.Context, evalItemID uuid.UUID) (GetReviewStatsForEvalItemRow, error) {
	row := q.db.QueryRowContext(ctx, getReviewStatsForEvalItem, evalItemID)
	var i GetReviewStatsForEvalItemRow
	err := row.Scan(
		&i.TotalReviews,
		&i.ApprovedCount,
		&i.RejectedCount,
		&i.NeedsRevisionCount,
		&i.ApprovalRate,
	)
	return i, err
}

const getReviewStatsForReviewer = `-- name: GetReviewStatsForReviewer :one
SELECT 
  COUNT(*) as total_reviews,
  COUNT(CASE WHEN verdict = 'APPROVED' THEN 1 END) as approved_count,
  COUNT(CASE WHEN verdict = 'REJECTED' THEN 1 END) as rejected_count,
  COUNT(CASE WHEN verdict = 'NEEDS_REVISION' THEN 1 END) as needs_revision_count
FROM eval_item_reviews 
WHERE reviewer_id = $1
`

type GetReviewStatsForReviewerRow struct {
	TotalReviews       int64 `json:"total_reviews"`
	ApprovedCount      int64 `json:"approved_count"`
	RejectedCount      int64 `json:"rejected_count"`
	NeedsRevisionCount int64 `json:"needs_revision_count"`
}

func (q *Queries) GetReviewStatsForReviewer(ctx context.Context, reviewerID uuid.UUID) (GetReviewStatsForReviewerRow, error) {
	row := q.db.QueryRowContext(ctx, getReviewStatsForReviewer, reviewerID)
	var i GetReviewStatsForReviewerRow
	err := row.Scan(
		&i.TotalReviews,
		&i.ApprovedCount,
		&i.RejectedCount,
		&i.NeedsRevisionCount,
	)
	return i, err
}

const getReviewsByEvalItem = `-- name: GetReviewsByEvalItem :many
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews WHERE eval_item_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetReviewsByEvalItem(ctx context.Context, evalItemID uuid.UUID) ([]EvalItemReview, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsByEvalItem, evalItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItemReview
	for rows.Next() {
		var i EvalItemReview
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.ReviewerID,
			&i.Verdict,
			pq.Array(&i.Reasons),
			&i.Comments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByEvalItemAndReviewer = `-- name: GetReviewsByEvalItemAndReviewer :one
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews 
WHERE eval_item_id = $1 AND reviewer_id = $2 
ORDER BY created_at DESC 
LIMIT 1
`

type GetReviewsByEvalItemAndReviewerParams struct {
	EvalItemID uuid.UUID `json:"eval_item_id"`
	ReviewerID uuid.UUID `json:"reviewer_id"`
}

func (q *Queries) GetReviewsByEvalItemAndReviewer(ctx context.Context, arg GetReviewsByEvalItemAndReviewerParams) (EvalItemReview, error) {
	row := q.db.QueryRowContext(ctx, getReviewsByEvalItemAndReviewer, arg.EvalItemID, arg.ReviewerID)
	var i EvalItemReview
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.ReviewerID,
		&i.Verdict,
		pq.Array(&i.Reasons),
		&i.Comments,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewsByReviewer = `-- name: GetReviewsByReviewer :many
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews WHERE reviewer_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetReviewsByReviewer(ctx context.Context, reviewerID uuid.UUID) ([]EvalItemReview, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsByReviewer, reviewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItemReview
	for rows.Next() {
		var i EvalItemReview
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.ReviewerID,
			&i.Verdict,
			pq.Array(&i.Reasons),
			&i.Comments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByVerdict = `-- name: GetReviewsByVerdict :many
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews WHERE verdict = $1 ORDER BY created_at DESC
`

func (q *Queries) GetReviewsByVerdict(ctx context.Context, verdict ReviewVerdict) ([]EvalItemReview, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsByVerdict, verdict)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItemReview
	for rows.Next() {
		var i EvalItemReview
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.ReviewerID,
			&i.Verdict,
			pq.Array(&i.Reasons),
			&i.Comments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsWithEvalItemDetails = `-- name: GetReviewsWithEvalItemDetails :many
SELECT 
  eir.id, eir.eval_item_id, eir.reviewer_id, eir.verdict, eir.reasons, eir.comments, eir.created_at, eir.updated_at,
  ei.prompt,
  ei.options,
  ei.correct_idx,
  e.title as eval_title
FROM eval_item_reviews eir
JOIN eval_items ei ON eir.eval_item_id = ei.id
JOIN evals e ON ei.eval_id = e.id
WHERE eir.reviewer_id = $1
ORDER BY eir.created_at DESC
LIMIT $2 OFFSET $3
`

type GetReviewsWithEvalItemDetailsParams struct {
	ReviewerID uuid.UUID `json:"reviewer_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

type GetReviewsWithEvalItemDetailsRow struct {
	ID         uuid.UUID      `json:"id"`
	EvalItemID uuid.UUID      `json:"eval_item_id"`
	ReviewerID uuid.UUID      `json:"reviewer_id"`
	Verdict    ReviewVerdict  `json:"verdict"`
	Reasons    []string       `json:"reasons"`
	Comments   sql.NullString `json:"comments"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
	Prompt     string         `json:"prompt"`
	Options    []string       `json:"options"`
	CorrectIdx int32          `json:"correct_idx"`
	EvalTitle  string         `json:"eval_title"`
}

func (q *Queries) GetReviewsWithEvalItemDetails(ctx context.Context, arg GetReviewsWithEvalItemDetailsParams) ([]GetReviewsWithEvalItemDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsWithEvalItemDetails, arg.ReviewerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsWithEvalItemDetailsRow
	for rows.Next() {
		var i GetReviewsWithEvalItemDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.ReviewerID,
			&i.Verdict,
			pq.Array(&i.Reasons),
			&i.Comments,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.EvalTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvalItemReviews = `-- name: ListEvalItemReviews :many
SELECT id, eval_item_id, reviewer_id, verdict, reasons, comments, created_at, updated_at FROM eval_item_reviews ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListEvalItemReviewsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEvalItemReviews(ctx context.Context, arg ListEvalItemReviewsParams) ([]EvalItemReview, error) {
	rows, err := q.db.QueryContext(ctx, listEvalItemReviews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItemReview
	for rows.Next() {
		var i EvalItemReview
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.ReviewerID,
			&i.Verdict,
			pq.Array(&i.Reasons),
			&i.Comments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
