// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: taxonomy.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const activateTaxonomyNode = `-- name: ActivateTaxonomyNode :one
WITH target AS (
  SELECT path FROM taxonomy_nodes WHERE taxonomy_nodes.id = $1
),
deactivated AS (
  UPDATE taxonomy_nodes SET
    is_active = false
  WHERE path = (SELECT path FROM target) AND taxonomy_nodes.id != $1
),
activated AS (
  UPDATE taxonomy_nodes SET
    is_active = true
  WHERE taxonomy_nodes.id = $1
  RETURNING id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at
)
SELECT id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at FROM activated
`

type ActivateTaxonomyNodeRow struct {
	ID               uuid.UUID       `json:"id"`
	Name             string          `json:"name"`
	Description      sql.NullString  `json:"description"`
	ParentID         uuid.NullUUID   `json:"parent_id"`
	Path             string          `json:"path"`
	Depth            int32           `json:"depth"`
	State            string          `json:"state"`
	Confidence       sql.NullFloat64 `json:"confidence"`
	SourceDocumentID uuid.NullUUID   `json:"source_document_id"`
	Version          int32           `json:"version"`
	IsActive         bool            `json:"is_active"`
	CreatedBy        uuid.NullUUID   `json:"created_by"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	CreatedAt        time.Time       `json:"created_at"`
	UpdatedAt        time.Time       `json:"updated_at"`
}

func (q *Queries) ActivateTaxonomyNode(ctx context.Context, id uuid.UUID) (ActivateTaxonomyNodeRow, error) {
	row := q.db.QueryRowContext(ctx, activateTaxonomyNode, id)
	var i ActivateTaxonomyNodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.Path,
		&i.Depth,
		&i.State,
		&i.Confidence,
		&i.SourceDocumentID,
		&i.Version,
		&i.IsActive,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDocumentTaxonomyLink = `-- name: CreateDocumentTaxonomyLink :one
INSERT INTO document_taxonomy_links (
  document_id, taxonomy_node_id, confidence, state, approved_by, approved_at
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING document_id, taxonomy_node_id, confidence, state, created_at, approved_by, approved_at
`

type CreateDocumentTaxonomyLinkParams struct {
	DocumentID     uuid.UUID       `json:"document_id"`
	TaxonomyNodeID uuid.UUID       `json:"taxonomy_node_id"`
	Confidence     sql.NullFloat64 `json:"confidence"`
	State          string          `json:"state"`
	ApprovedBy     uuid.NullUUID   `json:"approved_by"`
	ApprovedAt     sql.NullTime    `json:"approved_at"`
}

func (q *Queries) CreateDocumentTaxonomyLink(ctx context.Context, arg CreateDocumentTaxonomyLinkParams) (DocumentTaxonomyLink, error) {
	row := q.db.QueryRowContext(ctx, createDocumentTaxonomyLink,
		arg.DocumentID,
		arg.TaxonomyNodeID,
		arg.Confidence,
		arg.State,
		arg.ApprovedBy,
		arg.ApprovedAt,
	)
	var i DocumentTaxonomyLink
	err := row.Scan(
		&i.DocumentID,
		&i.TaxonomyNodeID,
		&i.Confidence,
		&i.State,
		&i.CreatedAt,
		&i.ApprovedBy,
		&i.ApprovedAt,
	)
	return i, err
}

const createTaxonomyNode = `-- name: CreateTaxonomyNode :one
WITH inserted AS (
  INSERT INTO taxonomy_nodes (
    name, description, parent_id, path, depth, state, confidence,
    source_document_id, version, is_active, created_by, approved_by, approved_at
  ) VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8,
    (SELECT COALESCE(MAX(version), 0) + 1 FROM taxonomy_nodes WHERE path = $4),
    $9, $10, $11, $12
  )
  RETURNING id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at
),
deactivated AS (
  UPDATE taxonomy_nodes SET
    is_active = false
  WHERE path = (SELECT path FROM inserted)
    AND taxonomy_nodes.id != (SELECT id FROM inserted)
    AND (SELECT is_active FROM inserted) = true
)
SELECT id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at FROM inserted
`

type CreateTaxonomyNodeParams struct {
	Name             string          `json:"name"`
	Description      sql.NullString  `json:"description"`
	ParentID         uuid.NullUUID   `json:"parent_id"`
	Path             string          `json:"path"`
	Depth            int32           `json:"depth"`
	State            string          `json:"state"`
	Confidence       sql.NullFloat64 `json:"confidence"`
	SourceDocumentID uuid.NullUUID   `json:"source_document_id"`
	IsActive         bool            `json:"is_active"`
	CreatedBy        uuid.NullUUID   `json:"created_by"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
}

type CreateTaxonomyNodeRow struct {
	ID               uuid.UUID       `json:"id"`
	Name             string          `json:"name"`
	Description      sql.NullString  `json:"description"`
	ParentID         uuid.NullUUID   `json:"parent_id"`
	Path             string          `json:"path"`
	Depth            int32           `json:"depth"`
	State            string          `json:"state"`
	Confidence       sql.NullFloat64 `json:"confidence"`
	SourceDocumentID uuid.NullUUID   `json:"source_document_id"`
	Version          int32           `json:"version"`
	IsActive         bool            `json:"is_active"`
	CreatedBy        uuid.NullUUID   `json:"created_by"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	CreatedAt        time.Time       `json:"created_at"`
	UpdatedAt        time.Time       `json:"updated_at"`
}

func (q *Queries) CreateTaxonomyNode(ctx context.Context, arg CreateTaxonomyNodeParams) (CreateTaxonomyNodeRow, error) {
	row := q.db.QueryRowContext(ctx, createTaxonomyNode,
		arg.Name,
		arg.Description,
		arg.ParentID,
		arg.Path,
		arg.Depth,
		arg.State,
		arg.Confidence,
		arg.SourceDocumentID,
		arg.IsActive,
		arg.CreatedBy,
		arg.ApprovedBy,
		arg.ApprovedAt,
	)
	var i CreateTaxonomyNodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.Path,
		&i.Depth,
		&i.State,
		&i.Confidence,
		&i.SourceDocumentID,
		&i.Version,
		&i.IsActive,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveTaxonomyNodeByPath = `-- name: GetActiveTaxonomyNodeByPath :one
SELECT id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at FROM taxonomy_nodes WHERE path = $1 AND is_active = true LIMIT 1
`

func (q *Queries) GetActiveTaxonomyNodeByPath(ctx context.Context, path string) (TaxonomyNode, error) {
	row := q.db.QueryRowContext(ctx, getActiveTaxonomyNodeByPath, path)
	var i TaxonomyNode
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.Path,
		&i.Depth,
		&i.State,
		&i.Confidence,
		&i.SourceDocumentID,
		&i.Version,
		&i.IsActive,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaxonomyNode = `-- name: GetTaxonomyNode :one
SELECT id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at FROM taxonomy_nodes WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTaxonomyNode(ctx context.Context, id uuid.UUID) (TaxonomyNode, error) {
	row := q.db.QueryRowContext(ctx, getTaxonomyNode, id)
	var i TaxonomyNode
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.Path,
		&i.Depth,
		&i.State,
		&i.Confidence,
		&i.SourceDocumentID,
		&i.Version,
		&i.IsActive,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDocumentsByTaxonomyPrefix = `-- name: ListDocumentsByTaxonomyPrefix :many
SELECT DISTINCT d.id, d.filename, d.title, d.mime_type, d.content, d.storage_path, d.rag_status, d.user_id, d.created_at, d.updated_at, d.storage_bucket, d.file_store_name, d.file_store_file_name
FROM documents d
JOIN document_taxonomy_links dtl ON d.id = dtl.document_id
JOIN taxonomy_nodes tn ON tn.id = dtl.taxonomy_node_id
WHERE tn.path LIKE $1 || '%'
  AND tn.state = 'approved'
  AND dtl.state = 'approved'
  AND tn.is_active = true
ORDER BY d.created_at DESC
`

func (q *Queries) ListDocumentsByTaxonomyPrefix(ctx context.Context, dollar_1 sql.NullString) ([]Document, error) {
	rows, err := q.db.QueryContext(ctx, listDocumentsByTaxonomyPrefix, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Title,
			&i.MimeType,
			&i.Content,
			&i.StoragePath,
			&i.RagStatus,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StorageBucket,
			&i.FileStoreName,
			&i.FileStoreFileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTaxonomyNodesByPrefix = `-- name: ListTaxonomyNodesByPrefix :many
SELECT id, name, description, parent_id, path, depth, state, confidence, source_document_id, version, is_active, created_by, approved_by, approved_at, created_at, updated_at FROM taxonomy_nodes WHERE path LIKE $1 || '%' ORDER BY path ASC, version DESC
`

func (q *Queries) ListTaxonomyNodesByPrefix(ctx context.Context, dollar_1 sql.NullString) ([]TaxonomyNode, error) {
	rows, err := q.db.QueryContext(ctx, listTaxonomyNodesByPrefix, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaxonomyNode
	for rows.Next() {
		var i TaxonomyNode
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.Path,
			&i.Depth,
			&i.State,
			&i.Confidence,
			&i.SourceDocumentID,
			&i.Version,
			&i.IsActive,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDocumentTaxonomyLinkState = `-- name: UpdateDocumentTaxonomyLinkState :one
UPDATE document_taxonomy_links SET
  state = $3,
  approved_by = $4,
  approved_at = $5
WHERE document_id = $1 AND taxonomy_node_id = $2
RETURNING document_id, taxonomy_node_id, confidence, state, created_at, approved_by, approved_at
`

type UpdateDocumentTaxonomyLinkStateParams struct {
	DocumentID     uuid.UUID     `json:"document_id"`
	TaxonomyNodeID uuid.UUID     `json:"taxonomy_node_id"`
	State          string        `json:"state"`
	ApprovedBy     uuid.NullUUID `json:"approved_by"`
	ApprovedAt     sql.NullTime  `json:"approved_at"`
}

func (q *Queries) UpdateDocumentTaxonomyLinkState(ctx context.Context, arg UpdateDocumentTaxonomyLinkStateParams) (DocumentTaxonomyLink, error) {
	row := q.db.QueryRowContext(ctx, updateDocumentTaxonomyLinkState,
		arg.DocumentID,
		arg.TaxonomyNodeID,
		arg.State,
		arg.ApprovedBy,
		arg.ApprovedAt,
	)
	var i DocumentTaxonomyLink
	err := row.Scan(
		&i.DocumentID,
		&i.TaxonomyNodeID,
		&i.Confidence,
		&i.State,
		&i.CreatedAt,
		&i.ApprovedBy,
		&i.ApprovedAt,
	)
	return i, err
}
