// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schema_templates.sql

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const activateSchemaTemplate = `-- name: ActivateSchemaTemplate :one
WITH target AS (
  SELECT schema_type FROM schema_templates WHERE schema_templates.id = $1
),
deactivated AS (
  UPDATE schema_templates SET
    is_active = false,
    locked_at = COALESCE(locked_at, now())
  WHERE schema_type = (SELECT schema_type FROM target) AND id != $1
),
activated AS (
  UPDATE schema_templates SET
    is_active = true
  WHERE id = $1
  RETURNING id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at
)
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM activated
`

type ActivateSchemaTemplateRow struct {
	ID           uuid.UUID       `json:"id"`
	SchemaType   string          `json:"schema_type"`
	Version      int32           `json:"version"`
	SchemaJson   json.RawMessage `json:"schema_json"`
	SubjectID    uuid.NullUUID   `json:"subject_id"`
	CurriculumID uuid.NullUUID   `json:"curriculum_id"`
	IsActive     bool            `json:"is_active"`
	CreatedBy    uuid.UUID       `json:"created_by"`
	CreatedAt    time.Time       `json:"created_at"`
	LockedAt     sql.NullTime    `json:"locked_at"`
}

func (q *Queries) ActivateSchemaTemplate(ctx context.Context, id uuid.UUID) (ActivateSchemaTemplateRow, error) {
	row := q.db.QueryRowContext(ctx, activateSchemaTemplate, id)
	var i ActivateSchemaTemplateRow
	err := row.Scan(
		&i.ID,
		&i.SchemaType,
		&i.Version,
		&i.SchemaJson,
		&i.SubjectID,
		&i.CurriculumID,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LockedAt,
	)
	return i, err
}

const createSchemaTemplate = `-- name: CreateSchemaTemplate :one
WITH inserted AS (
  INSERT INTO schema_templates (
    schema_type, version, schema_json, subject_id, curriculum_id,
    is_active, created_by, locked_at
  ) VALUES (
    $1,
    (SELECT COALESCE(MAX(version), 0) + 1 FROM schema_templates WHERE schema_type = $1),
    $2, $3, $4, $5, $6, $7
  )
  RETURNING id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at
),
deactivated AS (
  UPDATE schema_templates SET
    is_active = false,
    locked_at = COALESCE(locked_at, now())
  WHERE schema_type = (SELECT schema_type FROM inserted)
    AND id != (SELECT id FROM inserted)
    AND (SELECT is_active FROM inserted) = true
)
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM inserted
`

type CreateSchemaTemplateParams struct {
	SchemaType   string          `json:"schema_type"`
	SchemaJson   json.RawMessage `json:"schema_json"`
	SubjectID    uuid.NullUUID   `json:"subject_id"`
	CurriculumID uuid.NullUUID   `json:"curriculum_id"`
	IsActive     bool            `json:"is_active"`
	CreatedBy    uuid.UUID       `json:"created_by"`
	LockedAt     sql.NullTime    `json:"locked_at"`
}

type CreateSchemaTemplateRow struct {
	ID           uuid.UUID       `json:"id"`
	SchemaType   string          `json:"schema_type"`
	Version      int32           `json:"version"`
	SchemaJson   json.RawMessage `json:"schema_json"`
	SubjectID    uuid.NullUUID   `json:"subject_id"`
	CurriculumID uuid.NullUUID   `json:"curriculum_id"`
	IsActive     bool            `json:"is_active"`
	CreatedBy    uuid.UUID       `json:"created_by"`
	CreatedAt    time.Time       `json:"created_at"`
	LockedAt     sql.NullTime    `json:"locked_at"`
}

func (q *Queries) CreateSchemaTemplate(ctx context.Context, arg CreateSchemaTemplateParams) (CreateSchemaTemplateRow, error) {
	row := q.db.QueryRowContext(ctx, createSchemaTemplate,
		arg.SchemaType,
		arg.SchemaJson,
		arg.SubjectID,
		arg.CurriculumID,
		arg.IsActive,
		arg.CreatedBy,
		arg.LockedAt,
	)
	var i CreateSchemaTemplateRow
	err := row.Scan(
		&i.ID,
		&i.SchemaType,
		&i.Version,
		&i.SchemaJson,
		&i.SubjectID,
		&i.CurriculumID,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LockedAt,
	)
	return i, err
}

const getActiveSchemaTemplateByType = `-- name: GetActiveSchemaTemplateByType :one
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM schema_templates WHERE schema_type = $1 AND is_active = true LIMIT 1
`

func (q *Queries) GetActiveSchemaTemplateByType(ctx context.Context, schemaType string) (SchemaTemplate, error) {
	row := q.db.QueryRowContext(ctx, getActiveSchemaTemplateByType, schemaType)
	var i SchemaTemplate
	err := row.Scan(
		&i.ID,
		&i.SchemaType,
		&i.Version,
		&i.SchemaJson,
		&i.SubjectID,
		&i.CurriculumID,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LockedAt,
	)
	return i, err
}

const getSchemaTemplate = `-- name: GetSchemaTemplate :one
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM schema_templates WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSchemaTemplate(ctx context.Context, id uuid.UUID) (SchemaTemplate, error) {
	row := q.db.QueryRowContext(ctx, getSchemaTemplate, id)
	var i SchemaTemplate
	err := row.Scan(
		&i.ID,
		&i.SchemaType,
		&i.Version,
		&i.SchemaJson,
		&i.SubjectID,
		&i.CurriculumID,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.LockedAt,
	)
	return i, err
}

const listActiveSchemaTemplates = `-- name: ListActiveSchemaTemplates :many
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM schema_templates
WHERE is_active = true
ORDER BY schema_type ASC, version DESC
`

func (q *Queries) ListActiveSchemaTemplates(ctx context.Context) ([]SchemaTemplate, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSchemaTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchemaTemplate
	for rows.Next() {
		var i SchemaTemplate
		if err := rows.Scan(
			&i.ID,
			&i.SchemaType,
			&i.Version,
			&i.SchemaJson,
			&i.SubjectID,
			&i.CurriculumID,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.LockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemaTemplatesByType = `-- name: ListSchemaTemplatesByType :many
SELECT id, schema_type, version, schema_json, subject_id, curriculum_id, is_active, created_by, created_at, locked_at FROM schema_templates
WHERE schema_type = $1
ORDER BY version DESC
`

func (q *Queries) ListSchemaTemplatesByType(ctx context.Context, schemaType string) ([]SchemaTemplate, error) {
	rows, err := q.db.QueryContext(ctx, listSchemaTemplatesByType, schemaType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SchemaTemplate
	for rows.Next() {
		var i SchemaTemplate
		if err := rows.Scan(
			&i.ID,
			&i.SchemaType,
			&i.Version,
			&i.SchemaJson,
			&i.SubjectID,
			&i.CurriculumID,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.LockedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
