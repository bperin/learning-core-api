// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_answers.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createUserAnswer = `-- name: CreateUserAnswer :one
INSERT INTO user_answers (
  attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at
`

type CreateUserAnswerParams struct {
	AttemptID   uuid.UUID     `json:"attempt_id"`
	EvalItemID  uuid.UUID     `json:"eval_item_id"`
	SelectedIdx int32         `json:"selected_idx"`
	IsCorrect   bool          `json:"is_correct"`
	TimeSpent   sql.NullInt32 `json:"time_spent"`
	HintsUsed   int32         `json:"hints_used"`
}

func (q *Queries) CreateUserAnswer(ctx context.Context, arg CreateUserAnswerParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, createUserAnswer,
		arg.AttemptID,
		arg.EvalItemID,
		arg.SelectedIdx,
		arg.IsCorrect,
		arg.TimeSpent,
		arg.HintsUsed,
	)
	var i UserAnswer
	err := row.Scan(
		&i.ID,
		&i.AttemptID,
		&i.EvalItemID,
		&i.SelectedIdx,
		&i.IsCorrect,
		&i.TimeSpent,
		&i.HintsUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswerStatsForEvalItem = `-- name: GetAnswerStatsForEvalItem :one
SELECT 
  COUNT(*) as total_answers,
  COUNT(CASE WHEN is_correct = true THEN 1 END) as correct_answers,
  COUNT(CASE WHEN is_correct = false THEN 1 END) as incorrect_answers,
  CASE 
    WHEN COUNT(*) > 0 THEN 
      ROUND(COUNT(CASE WHEN is_correct = true THEN 1 END)::numeric / COUNT(*)::numeric * 100, 2)
    ELSE 0 
  END as success_rate,
  AVG(time_spent) as avg_time_spent,
  AVG(hints_used) as avg_hints_used
FROM user_answers 
WHERE eval_item_id = $1
`

type GetAnswerStatsForEvalItemRow struct {
	TotalAnswers     int64   `json:"total_answers"`
	CorrectAnswers   int64   `json:"correct_answers"`
	IncorrectAnswers int64   `json:"incorrect_answers"`
	SuccessRate      int32   `json:"success_rate"`
	AvgTimeSpent     float64 `json:"avg_time_spent"`
	AvgHintsUsed     float64 `json:"avg_hints_used"`
}

func (q *Queries) GetAnswerStatsForEvalItem(ctx context.Context, evalItemID uuid.UUID) (GetAnswerStatsForEvalItemRow, error) {
	row := q.db.QueryRowContext(ctx, getAnswerStatsForEvalItem, evalItemID)
	var i GetAnswerStatsForEvalItemRow
	err := row.Scan(
		&i.TotalAnswers,
		&i.CorrectAnswers,
		&i.IncorrectAnswers,
		&i.SuccessRate,
		&i.AvgTimeSpent,
		&i.AvgHintsUsed,
	)
	return i, err
}

const getAnswersByUserAndEval = `-- name: GetAnswersByUserAndEval :many
SELECT ua.id, ua.attempt_id, ua.eval_item_id, ua.selected_idx, ua.is_correct, ua.time_spent, ua.hints_used, ua.created_at, ua.updated_at, ei.prompt, ei.options, ei.correct_idx, ei.explanation
FROM user_answers ua
JOIN test_attempts ta ON ua.attempt_id = ta.id
JOIN eval_items ei ON ua.eval_item_id = ei.id
WHERE ta.user_id = $1 AND ta.eval_id = $2
ORDER BY ua.created_at ASC
`

type GetAnswersByUserAndEvalParams struct {
	UserID uuid.UUID `json:"user_id"`
	EvalID uuid.UUID `json:"eval_id"`
}

type GetAnswersByUserAndEvalRow struct {
	ID          uuid.UUID      `json:"id"`
	AttemptID   uuid.UUID      `json:"attempt_id"`
	EvalItemID  uuid.UUID      `json:"eval_item_id"`
	SelectedIdx int32          `json:"selected_idx"`
	IsCorrect   bool           `json:"is_correct"`
	TimeSpent   sql.NullInt32  `json:"time_spent"`
	HintsUsed   int32          `json:"hints_used"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	Prompt      string         `json:"prompt"`
	Options     []string       `json:"options"`
	CorrectIdx  int32          `json:"correct_idx"`
	Explanation sql.NullString `json:"explanation"`
}

func (q *Queries) GetAnswersByUserAndEval(ctx context.Context, arg GetAnswersByUserAndEvalParams) ([]GetAnswersByUserAndEvalRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnswersByUserAndEval, arg.UserID, arg.EvalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnswersByUserAndEvalRow
	for rows.Next() {
		var i GetAnswersByUserAndEvalRow
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Explanation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorrectAnswersByAttempt = `-- name: GetCorrectAnswersByAttempt :many
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers 
WHERE attempt_id = $1 AND is_correct = true 
ORDER BY created_at ASC
`

func (q *Queries) GetCorrectAnswersByAttempt(ctx context.Context, attemptID uuid.UUID) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, getCorrectAnswersByAttempt, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncorrectAnswersByAttempt = `-- name: GetIncorrectAnswersByAttempt :many
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers 
WHERE attempt_id = $1 AND is_correct = false 
ORDER BY created_at ASC
`

func (q *Queries) GetIncorrectAnswersByAttempt(ctx context.Context, attemptID uuid.UUID) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, getIncorrectAnswersByAttempt, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnswer = `-- name: GetUserAnswer :one
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserAnswer(ctx context.Context, id uuid.UUID) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, getUserAnswer, id)
	var i UserAnswer
	err := row.Scan(
		&i.ID,
		&i.AttemptID,
		&i.EvalItemID,
		&i.SelectedIdx,
		&i.IsCorrect,
		&i.TimeSpent,
		&i.HintsUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserAnswerByAttemptAndItem = `-- name: GetUserAnswerByAttemptAndItem :one
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers 
WHERE attempt_id = $1 AND eval_item_id = $2 
LIMIT 1
`

type GetUserAnswerByAttemptAndItemParams struct {
	AttemptID  uuid.UUID `json:"attempt_id"`
	EvalItemID uuid.UUID `json:"eval_item_id"`
}

func (q *Queries) GetUserAnswerByAttemptAndItem(ctx context.Context, arg GetUserAnswerByAttemptAndItemParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, getUserAnswerByAttemptAndItem, arg.AttemptID, arg.EvalItemID)
	var i UserAnswer
	err := row.Scan(
		&i.ID,
		&i.AttemptID,
		&i.EvalItemID,
		&i.SelectedIdx,
		&i.IsCorrect,
		&i.TimeSpent,
		&i.HintsUsed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserAnswerPatterns = `-- name: GetUserAnswerPatterns :many
SELECT 
  selected_idx,
  COUNT(*) as selection_count,
  COUNT(CASE WHEN is_correct = true THEN 1 END) as correct_count
FROM user_answers 
WHERE eval_item_id = $1
GROUP BY selected_idx
ORDER BY selected_idx
`

type GetUserAnswerPatternsRow struct {
	SelectedIdx    int32 `json:"selected_idx"`
	SelectionCount int64 `json:"selection_count"`
	CorrectCount   int64 `json:"correct_count"`
}

func (q *Queries) GetUserAnswerPatterns(ctx context.Context, evalItemID uuid.UUID) ([]GetUserAnswerPatternsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAnswerPatterns, evalItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnswerPatternsRow
	for rows.Next() {
		var i GetUserAnswerPatternsRow
		if err := rows.Scan(&i.SelectedIdx, &i.SelectionCount, &i.CorrectCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnswersByAttempt = `-- name: GetUserAnswersByAttempt :many
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers WHERE attempt_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetUserAnswersByAttempt(ctx context.Context, attemptID uuid.UUID) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, getUserAnswersByAttempt, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnswersByEvalItem = `-- name: GetUserAnswersByEvalItem :many
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers WHERE eval_item_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetUserAnswersByEvalItem(ctx context.Context, evalItemID uuid.UUID) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, getUserAnswersByEvalItem, evalItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAnswers = `-- name: ListUserAnswers :many
SELECT id, attempt_id, eval_item_id, selected_idx, is_correct, time_spent, hints_used, created_at, updated_at FROM user_answers ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListUserAnswersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserAnswers(ctx context.Context, arg ListUserAnswersParams) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, listUserAnswers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.ID,
			&i.AttemptID,
			&i.EvalItemID,
			&i.SelectedIdx,
			&i.IsCorrect,
			&i.TimeSpent,
			&i.HintsUsed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
