// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eval_results.sql

package store

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createEvalResult = `-- name: CreateEvalResult :one
INSERT INTO eval_results (
  eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at
`

type CreateEvalResultParams struct {
	EvalItemID        uuid.UUID             `json:"eval_item_id"`
	EvalType          string                `json:"eval_type"`
	EvalPromptID      uuid.UUID             `json:"eval_prompt_id"`
	Score             sql.NullFloat64       `json:"score"`
	IsGrounded        sql.NullBool          `json:"is_grounded"`
	Verdict           sql.NullString        `json:"verdict"`
	Reasoning         sql.NullString        `json:"reasoning"`
	UnsupportedClaims pqtype.NullRawMessage `json:"unsupported_claims"`
	GcpEvalID         sql.NullString        `json:"gcp_eval_id"`
}

func (q *Queries) CreateEvalResult(ctx context.Context, arg CreateEvalResultParams) (EvalResult, error) {
	row := q.db.QueryRowContext(ctx, createEvalResult,
		arg.EvalItemID,
		arg.EvalType,
		arg.EvalPromptID,
		arg.Score,
		arg.IsGrounded,
		arg.Verdict,
		arg.Reasoning,
		arg.UnsupportedClaims,
		arg.GcpEvalID,
	)
	var i EvalResult
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.EvalType,
		&i.EvalPromptID,
		&i.Score,
		&i.IsGrounded,
		&i.Verdict,
		&i.Reasoning,
		&i.UnsupportedClaims,
		&i.GcpEvalID,
		&i.CreatedAt,
	)
	return i, err
}

const getEvalResult = `-- name: GetEvalResult :one
SELECT id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at FROM eval_results WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEvalResult(ctx context.Context, id uuid.UUID) (EvalResult, error) {
	row := q.db.QueryRowContext(ctx, getEvalResult, id)
	var i EvalResult
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.EvalType,
		&i.EvalPromptID,
		&i.Score,
		&i.IsGrounded,
		&i.Verdict,
		&i.Reasoning,
		&i.UnsupportedClaims,
		&i.GcpEvalID,
		&i.CreatedAt,
	)
	return i, err
}

const getEvalResultStats = `-- name: GetEvalResultStats :one
SELECT 
  COUNT(*) as total_evals,
  COUNT(CASE WHEN verdict = 'PASS' THEN 1 END) as passed,
  COUNT(CASE WHEN verdict = 'FAIL' THEN 1 END) as failed,
  COUNT(CASE WHEN verdict = 'WARN' THEN 1 END) as warned,
  ROUND(AVG(score)::numeric, 2) as avg_score
FROM eval_results 
WHERE eval_type = $1
`

type GetEvalResultStatsRow struct {
	TotalEvals int64  `json:"total_evals"`
	Passed     int64  `json:"passed"`
	Failed     int64  `json:"failed"`
	Warned     int64  `json:"warned"`
	AvgScore   string `json:"avg_score"`
}

func (q *Queries) GetEvalResultStats(ctx context.Context, evalType string) (GetEvalResultStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEvalResultStats, evalType)
	var i GetEvalResultStatsRow
	err := row.Scan(
		&i.TotalEvals,
		&i.Passed,
		&i.Failed,
		&i.Warned,
		&i.AvgScore,
	)
	return i, err
}

const getEvalResultsByEvalItem = `-- name: GetEvalResultsByEvalItem :many
SELECT id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at FROM eval_results WHERE eval_item_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetEvalResultsByEvalItem(ctx context.Context, evalItemID uuid.UUID) ([]EvalResult, error) {
	rows, err := q.db.QueryContext(ctx, getEvalResultsByEvalItem, evalItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalResult
	for rows.Next() {
		var i EvalResult
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.EvalType,
			&i.EvalPromptID,
			&i.Score,
			&i.IsGrounded,
			&i.Verdict,
			&i.Reasoning,
			&i.UnsupportedClaims,
			&i.GcpEvalID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvalResultsByType = `-- name: GetEvalResultsByType :many
SELECT id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at FROM eval_results WHERE eval_type = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type GetEvalResultsByTypeParams struct {
	EvalType string `json:"eval_type"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetEvalResultsByType(ctx context.Context, arg GetEvalResultsByTypeParams) ([]EvalResult, error) {
	rows, err := q.db.QueryContext(ctx, getEvalResultsByType, arg.EvalType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalResult
	for rows.Next() {
		var i EvalResult
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.EvalType,
			&i.EvalPromptID,
			&i.Score,
			&i.IsGrounded,
			&i.Verdict,
			&i.Reasoning,
			&i.UnsupportedClaims,
			&i.GcpEvalID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEvalResultForItem = `-- name: GetLatestEvalResultForItem :one
SELECT id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at FROM eval_results WHERE eval_item_id = $1 AND eval_type = $2 ORDER BY created_at DESC LIMIT 1
`

type GetLatestEvalResultForItemParams struct {
	EvalItemID uuid.UUID `json:"eval_item_id"`
	EvalType   string    `json:"eval_type"`
}

func (q *Queries) GetLatestEvalResultForItem(ctx context.Context, arg GetLatestEvalResultForItemParams) (EvalResult, error) {
	row := q.db.QueryRowContext(ctx, getLatestEvalResultForItem, arg.EvalItemID, arg.EvalType)
	var i EvalResult
	err := row.Scan(
		&i.ID,
		&i.EvalItemID,
		&i.EvalType,
		&i.EvalPromptID,
		&i.Score,
		&i.IsGrounded,
		&i.Verdict,
		&i.Reasoning,
		&i.UnsupportedClaims,
		&i.GcpEvalID,
		&i.CreatedAt,
	)
	return i, err
}

const listEvalResults = `-- name: ListEvalResults :many
SELECT id, eval_item_id, eval_type, eval_prompt_id, score, is_grounded, verdict, reasoning, unsupported_claims, gcp_eval_id, created_at FROM eval_results ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListEvalResultsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEvalResults(ctx context.Context, arg ListEvalResultsParams) ([]EvalResult, error) {
	rows, err := q.db.QueryContext(ctx, listEvalResults, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalResult
	for rows.Next() {
		var i EvalResult
		if err := rows.Scan(
			&i.ID,
			&i.EvalItemID,
			&i.EvalType,
			&i.EvalPromptID,
			&i.Score,
			&i.IsGrounded,
			&i.Verdict,
			&i.Reasoning,
			&i.UnsupportedClaims,
			&i.GcpEvalID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
