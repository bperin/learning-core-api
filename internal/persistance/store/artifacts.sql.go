// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: artifacts.sql

package store

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createArtifact = `-- name: CreateArtifact :one
INSERT INTO artifacts (
  type, status, document_id, eval_id, eval_item_id, attempt_id, user_id,
  text, json, model, prompt, input_hash, meta, error
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at
`

type CreateArtifactParams struct {
	Type       string                `json:"type"`
	Status     string                `json:"status"`
	DocumentID uuid.NullUUID         `json:"document_id"`
	EvalID     uuid.NullUUID         `json:"eval_id"`
	EvalItemID uuid.NullUUID         `json:"eval_item_id"`
	AttemptID  uuid.NullUUID         `json:"attempt_id"`
	UserID     uuid.NullUUID         `json:"user_id"`
	Text       sql.NullString        `json:"text"`
	Json       pqtype.NullRawMessage `json:"json"`
	Model      sql.NullString        `json:"model"`
	Prompt     sql.NullString        `json:"prompt"`
	InputHash  sql.NullString        `json:"input_hash"`
	Meta       pqtype.NullRawMessage `json:"meta"`
	Error      sql.NullString        `json:"error"`
}

func (q *Queries) CreateArtifact(ctx context.Context, arg CreateArtifactParams) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, createArtifact,
		arg.Type,
		arg.Status,
		arg.DocumentID,
		arg.EvalID,
		arg.EvalItemID,
		arg.AttemptID,
		arg.UserID,
		arg.Text,
		arg.Json,
		arg.Model,
		arg.Prompt,
		arg.InputHash,
		arg.Meta,
		arg.Error,
	)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.DocumentID,
		&i.EvalID,
		&i.EvalItemID,
		&i.AttemptID,
		&i.UserID,
		&i.Text,
		&i.Json,
		&i.Model,
		&i.Prompt,
		&i.InputHash,
		&i.Meta,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteArtifact = `-- name: DeleteArtifact :exec
DELETE FROM artifacts WHERE id = $1
`

func (q *Queries) DeleteArtifact(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteArtifact, id)
	return err
}

const getArtifact = `-- name: GetArtifact :one
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE id = $1 LIMIT 1
`

func (q *Queries) GetArtifact(ctx context.Context, id uuid.UUID) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, getArtifact, id)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.DocumentID,
		&i.EvalID,
		&i.EvalItemID,
		&i.AttemptID,
		&i.UserID,
		&i.Text,
		&i.Json,
		&i.Model,
		&i.Prompt,
		&i.InputHash,
		&i.Meta,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getArtifactStats = `-- name: GetArtifactStats :one
SELECT 
  COUNT(*) as total_artifacts,
  COUNT(CASE WHEN status = 'READY' THEN 1 END) as ready_count,
  COUNT(CASE WHEN status = 'PENDING' THEN 1 END) as pending_count,
  COUNT(CASE WHEN status = 'ERROR' THEN 1 END) as error_count,
  COUNT(CASE WHEN error IS NOT NULL THEN 1 END) as with_errors
FROM artifacts
`

type GetArtifactStatsRow struct {
	TotalArtifacts int64 `json:"total_artifacts"`
	ReadyCount     int64 `json:"ready_count"`
	PendingCount   int64 `json:"pending_count"`
	ErrorCount     int64 `json:"error_count"`
	WithErrors     int64 `json:"with_errors"`
}

func (q *Queries) GetArtifactStats(ctx context.Context) (GetArtifactStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getArtifactStats)
	var i GetArtifactStatsRow
	err := row.Scan(
		&i.TotalArtifacts,
		&i.ReadyCount,
		&i.PendingCount,
		&i.ErrorCount,
		&i.WithErrors,
	)
	return i, err
}

const getArtifactsByAttempt = `-- name: GetArtifactsByAttempt :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE attempt_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByAttempt(ctx context.Context, attemptID uuid.NullUUID) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByAttempt, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByDocument = `-- name: GetArtifactsByDocument :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE document_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByDocument(ctx context.Context, documentID uuid.NullUUID) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByDocument, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByEval = `-- name: GetArtifactsByEval :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE eval_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByEval(ctx context.Context, evalID uuid.NullUUID) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByEvalItem = `-- name: GetArtifactsByEvalItem :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE eval_item_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByEvalItem(ctx context.Context, evalItemID uuid.NullUUID) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByEvalItem, evalItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByInputHash = `-- name: GetArtifactsByInputHash :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts 
WHERE input_hash = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByInputHash(ctx context.Context, inputHash sql.NullString) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByInputHash, inputHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByStatus = `-- name: GetArtifactsByStatus :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByStatus(ctx context.Context, status string) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByType = `-- name: GetArtifactsByType :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE type = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByType(ctx context.Context, type_ string) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByTypeAndEntity = `-- name: GetArtifactsByTypeAndEntity :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts 
WHERE type = $1 
AND (
  (document_id = $2 AND $2 IS NOT NULL) OR
  (eval_id = $3 AND $3 IS NOT NULL) OR
  (eval_item_id = $4 AND $4 IS NOT NULL) OR
  (attempt_id = $5 AND $5 IS NOT NULL)
)
ORDER BY created_at DESC
`

type GetArtifactsByTypeAndEntityParams struct {
	Type       string        `json:"type"`
	DocumentID uuid.NullUUID `json:"document_id"`
	EvalID     uuid.NullUUID `json:"eval_id"`
	EvalItemID uuid.NullUUID `json:"eval_item_id"`
	AttemptID  uuid.NullUUID `json:"attempt_id"`
}

func (q *Queries) GetArtifactsByTypeAndEntity(ctx context.Context, arg GetArtifactsByTypeAndEntityParams) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByTypeAndEntity,
		arg.Type,
		arg.DocumentID,
		arg.EvalID,
		arg.EvalItemID,
		arg.AttemptID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtifactsByUser = `-- name: GetArtifactsByUser :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetArtifactsByUser(ctx context.Context, userID uuid.NullUUID) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, getArtifactsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestArtifactByTypeAndEntity = `-- name: GetLatestArtifactByTypeAndEntity :one
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts 
WHERE type = $1 
AND (
  (document_id = $2 AND $2 IS NOT NULL) OR
  (eval_id = $3 AND $3 IS NOT NULL) OR
  (eval_item_id = $4 AND $4 IS NOT NULL) OR
  (attempt_id = $5 AND $5 IS NOT NULL)
)
ORDER BY created_at DESC 
LIMIT 1
`

type GetLatestArtifactByTypeAndEntityParams struct {
	Type       string        `json:"type"`
	DocumentID uuid.NullUUID `json:"document_id"`
	EvalID     uuid.NullUUID `json:"eval_id"`
	EvalItemID uuid.NullUUID `json:"eval_item_id"`
	AttemptID  uuid.NullUUID `json:"attempt_id"`
}

func (q *Queries) GetLatestArtifactByTypeAndEntity(ctx context.Context, arg GetLatestArtifactByTypeAndEntityParams) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, getLatestArtifactByTypeAndEntity,
		arg.Type,
		arg.DocumentID,
		arg.EvalID,
		arg.EvalItemID,
		arg.AttemptID,
	)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.DocumentID,
		&i.EvalID,
		&i.EvalItemID,
		&i.AttemptID,
		&i.UserID,
		&i.Text,
		&i.Json,
		&i.Model,
		&i.Prompt,
		&i.InputHash,
		&i.Meta,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArtifacts = `-- name: ListArtifacts :many
SELECT id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at FROM artifacts ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListArtifactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListArtifacts(ctx context.Context, arg ListArtifactsParams) ([]Artifact, error) {
	rows, err := q.db.QueryContext(ctx, listArtifacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artifact
	for rows.Next() {
		var i Artifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Status,
			&i.DocumentID,
			&i.EvalID,
			&i.EvalItemID,
			&i.AttemptID,
			&i.UserID,
			&i.Text,
			&i.Json,
			&i.Model,
			&i.Prompt,
			&i.InputHash,
			&i.Meta,
			&i.Error,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArtifact = `-- name: UpdateArtifact :one
UPDATE artifacts SET
  status = COALESCE($2, status),
  text = COALESCE($3, text),
  json = COALESCE($4, json),
  model = COALESCE($5, model),
  prompt = COALESCE($6, prompt),
  meta = COALESCE($7, meta),
  error = COALESCE($8, error)
WHERE id = $1
RETURNING id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at
`

type UpdateArtifactParams struct {
	ID     uuid.UUID             `json:"id"`
	Status string                `json:"status"`
	Text   sql.NullString        `json:"text"`
	Json   pqtype.NullRawMessage `json:"json"`
	Model  sql.NullString        `json:"model"`
	Prompt sql.NullString        `json:"prompt"`
	Meta   pqtype.NullRawMessage `json:"meta"`
	Error  sql.NullString        `json:"error"`
}

func (q *Queries) UpdateArtifact(ctx context.Context, arg UpdateArtifactParams) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, updateArtifact,
		arg.ID,
		arg.Status,
		arg.Text,
		arg.Json,
		arg.Model,
		arg.Prompt,
		arg.Meta,
		arg.Error,
	)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.DocumentID,
		&i.EvalID,
		&i.EvalItemID,
		&i.AttemptID,
		&i.UserID,
		&i.Text,
		&i.Json,
		&i.Model,
		&i.Prompt,
		&i.InputHash,
		&i.Meta,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateArtifactStatus = `-- name: UpdateArtifactStatus :one
UPDATE artifacts SET
  status = $2
WHERE id = $1
RETURNING id, type, status, document_id, eval_id, eval_item_id, attempt_id, user_id, text, json, model, prompt, input_hash, meta, error, created_at, updated_at
`

type UpdateArtifactStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateArtifactStatus(ctx context.Context, arg UpdateArtifactStatusParams) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, updateArtifactStatus, arg.ID, arg.Status)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Status,
		&i.DocumentID,
		&i.EvalID,
		&i.EvalItemID,
		&i.AttemptID,
		&i.UserID,
		&i.Text,
		&i.Json,
		&i.Model,
		&i.Prompt,
		&i.InputHash,
		&i.Meta,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
