// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: test_attempts.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const completeTestAttempt = `-- name: CompleteTestAttempt :one
UPDATE test_attempts SET
  score = $2,
  percentage = CASE 
    WHEN total > 0 THEN ROUND(($2::numeric / total::numeric) * 100, 2)
    ELSE 0 
  END,
  total_time = $3,
  feedback = $4,
  summary = $5,
  completed_at = now()
WHERE id = $1
RETURNING id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at
`

type CompleteTestAttemptParams struct {
	ID        uuid.UUID             `json:"id"`
	Score     int32                 `json:"score"`
	TotalTime sql.NullInt32         `json:"total_time"`
	Feedback  pqtype.NullRawMessage `json:"feedback"`
	Summary   sql.NullString        `json:"summary"`
}

func (q *Queries) CompleteTestAttempt(ctx context.Context, arg CompleteTestAttemptParams) (TestAttempt, error) {
	row := q.db.QueryRowContext(ctx, completeTestAttempt,
		arg.ID,
		arg.Score,
		arg.TotalTime,
		arg.Feedback,
		arg.Summary,
	)
	var i TestAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createTestAttempt = `-- name: CreateTestAttempt :one
INSERT INTO test_attempts (
  user_id, eval_id, total
) VALUES (
  $1, $2, $3
) RETURNING id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at
`

type CreateTestAttemptParams struct {
	UserID uuid.UUID `json:"user_id"`
	EvalID uuid.UUID `json:"eval_id"`
	Total  int32     `json:"total"`
}

func (q *Queries) CreateTestAttempt(ctx context.Context, arg CreateTestAttemptParams) (TestAttempt, error) {
	row := q.db.QueryRowContext(ctx, createTestAttempt, arg.UserID, arg.EvalID, arg.Total)
	var i TestAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteTestAttempt = `-- name: DeleteTestAttempt :exec
DELETE FROM test_attempts WHERE id = $1
`

func (q *Queries) DeleteTestAttempt(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTestAttempt, id)
	return err
}

const getActiveAttempts = `-- name: GetActiveAttempts :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts WHERE completed_at IS NULL ORDER BY started_at DESC
`

func (q *Queries) GetActiveAttempts(ctx context.Context) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getActiveAttempts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletedAttempts = `-- name: GetCompletedAttempts :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts WHERE completed_at IS NOT NULL ORDER BY completed_at DESC
`

func (q *Queries) GetCompletedAttempts(ctx context.Context) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getCompletedAttempts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvalTestStats = `-- name: GetEvalTestStats :one
SELECT 
  COUNT(*) as total_attempts,
  COUNT(CASE WHEN completed_at IS NOT NULL THEN 1 END) as completed_attempts,
  AVG(CASE WHEN percentage IS NOT NULL THEN percentage END) as avg_percentage,
  COUNT(DISTINCT user_id) as unique_users
FROM test_attempts 
WHERE eval_id = $1
`

type GetEvalTestStatsRow struct {
	TotalAttempts     int64   `json:"total_attempts"`
	CompletedAttempts int64   `json:"completed_attempts"`
	AvgPercentage     float64 `json:"avg_percentage"`
	UniqueUsers       int64   `json:"unique_users"`
}

func (q *Queries) GetEvalTestStats(ctx context.Context, evalID uuid.UUID) (GetEvalTestStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEvalTestStats, evalID)
	var i GetEvalTestStatsRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.CompletedAttempts,
		&i.AvgPercentage,
		&i.UniqueUsers,
	)
	return i, err
}

const getTestAttempt = `-- name: GetTestAttempt :one
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTestAttempt(ctx context.Context, id uuid.UUID) (TestAttempt, error) {
	row := q.db.QueryRowContext(ctx, getTestAttempt, id)
	var i TestAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTestAttemptWithAnswers = `-- name: GetTestAttemptWithAnswers :one
SELECT 
  ta.id, ta.user_id, ta.eval_id, ta.score, ta.total, ta.percentage, ta.total_time, ta.feedback, ta.summary, ta.started_at, ta.completed_at,
  COUNT(ua.id) as answer_count,
  COUNT(CASE WHEN ua.is_correct = true THEN 1 END) as correct_count
FROM test_attempts ta
LEFT JOIN user_answers ua ON ta.id = ua.attempt_id
WHERE ta.id = $1
GROUP BY ta.id
`

type GetTestAttemptWithAnswersRow struct {
	ID           uuid.UUID             `json:"id"`
	UserID       uuid.UUID             `json:"user_id"`
	EvalID       uuid.UUID             `json:"eval_id"`
	Score        int32                 `json:"score"`
	Total        int32                 `json:"total"`
	Percentage   sql.NullFloat64       `json:"percentage"`
	TotalTime    sql.NullInt32         `json:"total_time"`
	Feedback     pqtype.NullRawMessage `json:"feedback"`
	Summary      sql.NullString        `json:"summary"`
	StartedAt    time.Time             `json:"started_at"`
	CompletedAt  sql.NullTime          `json:"completed_at"`
	AnswerCount  int64                 `json:"answer_count"`
	CorrectCount int64                 `json:"correct_count"`
}

func (q *Queries) GetTestAttemptWithAnswers(ctx context.Context, id uuid.UUID) (GetTestAttemptWithAnswersRow, error) {
	row := q.db.QueryRowContext(ctx, getTestAttemptWithAnswers, id)
	var i GetTestAttemptWithAnswersRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
		&i.AnswerCount,
		&i.CorrectCount,
	)
	return i, err
}

const getTestAttemptsByEval = `-- name: GetTestAttemptsByEval :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts WHERE eval_id = $1 ORDER BY started_at DESC
`

func (q *Queries) GetTestAttemptsByEval(ctx context.Context, evalID uuid.UUID) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getTestAttemptsByEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestAttemptsByUser = `-- name: GetTestAttemptsByUser :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts WHERE user_id = $1 ORDER BY started_at DESC
`

func (q *Queries) GetTestAttemptsByUser(ctx context.Context, userID uuid.UUID) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getTestAttemptsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAttemptsByEval = `-- name: GetUserAttemptsByEval :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts 
WHERE user_id = $1 AND eval_id = $2 
ORDER BY started_at DESC
`

type GetUserAttemptsByEvalParams struct {
	UserID uuid.UUID `json:"user_id"`
	EvalID uuid.UUID `json:"eval_id"`
}

func (q *Queries) GetUserAttemptsByEval(ctx context.Context, arg GetUserAttemptsByEvalParams) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getUserAttemptsByEval, arg.UserID, arg.EvalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTestStats = `-- name: GetUserTestStats :one
SELECT 
  COUNT(*) as total_attempts,
  COUNT(CASE WHEN completed_at IS NOT NULL THEN 1 END) as completed_attempts,
  AVG(CASE WHEN percentage IS NOT NULL THEN percentage END) as avg_percentage,
  MAX(percentage) as best_percentage,
  AVG(CASE WHEN total_time IS NOT NULL THEN total_time END) as avg_time
FROM test_attempts 
WHERE user_id = $1
`

type GetUserTestStatsRow struct {
	TotalAttempts     int64       `json:"total_attempts"`
	CompletedAttempts int64       `json:"completed_attempts"`
	AvgPercentage     float64     `json:"avg_percentage"`
	BestPercentage    interface{} `json:"best_percentage"`
	AvgTime           float64     `json:"avg_time"`
}

func (q *Queries) GetUserTestStats(ctx context.Context, userID uuid.UUID) (GetUserTestStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserTestStats, userID)
	var i GetUserTestStatsRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.CompletedAttempts,
		&i.AvgPercentage,
		&i.BestPercentage,
		&i.AvgTime,
	)
	return i, err
}

const listTestAttempts = `-- name: ListTestAttempts :many
SELECT id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at FROM test_attempts ORDER BY started_at DESC LIMIT $1 OFFSET $2
`

type ListTestAttemptsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTestAttempts(ctx context.Context, arg ListTestAttemptsParams) ([]TestAttempt, error) {
	rows, err := q.db.QueryContext(ctx, listTestAttempts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestAttempt
	for rows.Next() {
		var i TestAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EvalID,
			&i.Score,
			&i.Total,
			&i.Percentage,
			&i.TotalTime,
			&i.Feedback,
			&i.Summary,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTestAttemptScore = `-- name: UpdateTestAttemptScore :one
UPDATE test_attempts SET
  score = $2,
  percentage = CASE 
    WHEN total > 0 THEN ROUND(($2::numeric / total::numeric) * 100, 2)
    ELSE 0 
  END,
  updated_at = now()
WHERE id = $1
RETURNING id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at
`

type UpdateTestAttemptScoreParams struct {
	ID    uuid.UUID `json:"id"`
	Score int32     `json:"score"`
}

func (q *Queries) UpdateTestAttemptScore(ctx context.Context, arg UpdateTestAttemptScoreParams) (TestAttempt, error) {
	row := q.db.QueryRowContext(ctx, updateTestAttemptScore, arg.ID, arg.Score)
	var i TestAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateTestAttemptTime = `-- name: UpdateTestAttemptTime :one
UPDATE test_attempts SET
  total_time = $2
WHERE id = $1
RETURNING id, user_id, eval_id, score, total, percentage, total_time, feedback, summary, started_at, completed_at
`

type UpdateTestAttemptTimeParams struct {
	ID        uuid.UUID     `json:"id"`
	TotalTime sql.NullInt32 `json:"total_time"`
}

func (q *Queries) UpdateTestAttemptTime(ctx context.Context, arg UpdateTestAttemptTimeParams) (TestAttempt, error) {
	row := q.db.QueryRowContext(ctx, updateTestAttemptTime, arg.ID, arg.TotalTime)
	var i TestAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EvalID,
		&i.Score,
		&i.Total,
		&i.Percentage,
		&i.TotalTime,
		&i.Feedback,
		&i.Summary,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}
