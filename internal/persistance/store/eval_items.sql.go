// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eval_items.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createEvalItem = `-- name: CreateEvalItem :one
INSERT INTO eval_items (
  eval_id, prompt, options, correct_idx, hint, explanation, metadata
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at
`

type CreateEvalItemParams struct {
	EvalID      uuid.UUID             `json:"eval_id"`
	Prompt      string                `json:"prompt"`
	Options     []string              `json:"options"`
	CorrectIdx  int32                 `json:"correct_idx"`
	Hint        sql.NullString        `json:"hint"`
	Explanation sql.NullString        `json:"explanation"`
	Metadata    pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) CreateEvalItem(ctx context.Context, arg CreateEvalItemParams) (EvalItem, error) {
	row := q.db.QueryRowContext(ctx, createEvalItem,
		arg.EvalID,
		arg.Prompt,
		pq.Array(arg.Options),
		arg.CorrectIdx,
		arg.Hint,
		arg.Explanation,
		arg.Metadata,
	)
	var i EvalItem
	err := row.Scan(
		&i.ID,
		&i.EvalID,
		&i.Prompt,
		pq.Array(&i.Options),
		&i.CorrectIdx,
		&i.Hint,
		&i.Explanation,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvalItem = `-- name: DeleteEvalItem :exec
DELETE FROM eval_items 
WHERE eval_items.id = $1 
AND eval_items.eval_id IN (SELECT e.id FROM evals e WHERE e.status = 'draft')
`

func (q *Queries) DeleteEvalItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteEvalItem, id)
	return err
}

const getEvalItem = `-- name: GetEvalItem :one
SELECT id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at FROM eval_items WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEvalItem(ctx context.Context, id uuid.UUID) (EvalItem, error) {
	row := q.db.QueryRowContext(ctx, getEvalItem, id)
	var i EvalItem
	err := row.Scan(
		&i.ID,
		&i.EvalID,
		&i.Prompt,
		pq.Array(&i.Options),
		&i.CorrectIdx,
		&i.Hint,
		&i.Explanation,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEvalItemWithReviews = `-- name: GetEvalItemWithReviews :one
SELECT 
  ei.id, ei.eval_id, ei.prompt, ei.options, ei.correct_idx, ei.hint, ei.explanation, ei.metadata, ei.created_at, ei.updated_at,
  COUNT(eir.id) as review_count,
  COUNT(CASE WHEN eir.verdict = 'APPROVED' THEN 1 END) as approved_count,
  COUNT(CASE WHEN eir.verdict = 'REJECTED' THEN 1 END) as rejected_count,
  COUNT(CASE WHEN eir.verdict = 'NEEDS_REVISION' THEN 1 END) as needs_revision_count
FROM eval_items ei
LEFT JOIN eval_item_reviews eir ON ei.id = eir.eval_item_id
WHERE ei.id = $1
GROUP BY ei.id
`

type GetEvalItemWithReviewsRow struct {
	ID                 uuid.UUID             `json:"id"`
	EvalID             uuid.UUID             `json:"eval_id"`
	Prompt             string                `json:"prompt"`
	Options            []string              `json:"options"`
	CorrectIdx         int32                 `json:"correct_idx"`
	Hint               sql.NullString        `json:"hint"`
	Explanation        sql.NullString        `json:"explanation"`
	Metadata           pqtype.NullRawMessage `json:"metadata"`
	CreatedAt          time.Time             `json:"created_at"`
	UpdatedAt          time.Time             `json:"updated_at"`
	ReviewCount        int64                 `json:"review_count"`
	ApprovedCount      int64                 `json:"approved_count"`
	RejectedCount      int64                 `json:"rejected_count"`
	NeedsRevisionCount int64                 `json:"needs_revision_count"`
}

func (q *Queries) GetEvalItemWithReviews(ctx context.Context, id uuid.UUID) (GetEvalItemWithReviewsRow, error) {
	row := q.db.QueryRowContext(ctx, getEvalItemWithReviews, id)
	var i GetEvalItemWithReviewsRow
	err := row.Scan(
		&i.ID,
		&i.EvalID,
		&i.Prompt,
		pq.Array(&i.Options),
		&i.CorrectIdx,
		&i.Hint,
		&i.Explanation,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReviewCount,
		&i.ApprovedCount,
		&i.RejectedCount,
		&i.NeedsRevisionCount,
	)
	return i, err
}

const getEvalItemsByEval = `-- name: GetEvalItemsByEval :many
SELECT id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at FROM eval_items WHERE eval_id = $1 ORDER BY id ASC
`

func (q *Queries) GetEvalItemsByEval(ctx context.Context, evalID uuid.UUID) ([]EvalItem, error) {
	rows, err := q.db.QueryContext(ctx, getEvalItemsByEval, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItem
	for rows.Next() {
		var i EvalItem
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvalItemsWithAnswerStats = `-- name: GetEvalItemsWithAnswerStats :many
SELECT 
  ei.id, ei.eval_id, ei.prompt, ei.options, ei.correct_idx, ei.hint, ei.explanation, ei.metadata, ei.created_at, ei.updated_at,
  COUNT(ua.id) as total_answers,
  COUNT(CASE WHEN ua.is_correct = true THEN 1 END) as correct_answers,
  CASE 
    WHEN COUNT(ua.id) > 0 THEN 
      ROUND(COUNT(CASE WHEN ua.is_correct = true THEN 1 END)::numeric / COUNT(ua.id)::numeric * 100, 2)
    ELSE 0 
  END as success_rate
FROM eval_items ei
LEFT JOIN user_answers ua ON ei.id = ua.eval_item_id
WHERE ei.eval_id = $1
GROUP BY ei.id
ORDER BY ei.id ASC
`

type GetEvalItemsWithAnswerStatsRow struct {
	ID             uuid.UUID             `json:"id"`
	EvalID         uuid.UUID             `json:"eval_id"`
	Prompt         string                `json:"prompt"`
	Options        []string              `json:"options"`
	CorrectIdx     int32                 `json:"correct_idx"`
	Hint           sql.NullString        `json:"hint"`
	Explanation    sql.NullString        `json:"explanation"`
	Metadata       pqtype.NullRawMessage `json:"metadata"`
	CreatedAt      time.Time             `json:"created_at"`
	UpdatedAt      time.Time             `json:"updated_at"`
	TotalAnswers   int64                 `json:"total_answers"`
	CorrectAnswers int64                 `json:"correct_answers"`
	SuccessRate    int32                 `json:"success_rate"`
}

func (q *Queries) GetEvalItemsWithAnswerStats(ctx context.Context, evalID uuid.UUID) ([]GetEvalItemsWithAnswerStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEvalItemsWithAnswerStats, evalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEvalItemsWithAnswerStatsRow
	for rows.Next() {
		var i GetEvalItemsWithAnswerStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalAnswers,
			&i.CorrectAnswers,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomEvalItems = `-- name: GetRandomEvalItems :many
SELECT id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at FROM eval_items 
WHERE eval_id = $1 
ORDER BY RANDOM() 
LIMIT $2
`

type GetRandomEvalItemsParams struct {
	EvalID uuid.UUID `json:"eval_id"`
	Limit  int32     `json:"limit"`
}

func (q *Queries) GetRandomEvalItems(ctx context.Context, arg GetRandomEvalItemsParams) ([]EvalItem, error) {
	rows, err := q.db.QueryContext(ctx, getRandomEvalItems, arg.EvalID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItem
	for rows.Next() {
		var i EvalItem
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvalItems = `-- name: ListEvalItems :many
SELECT id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at FROM eval_items ORDER BY id DESC LIMIT $1 OFFSET $2
`

type ListEvalItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEvalItems(ctx context.Context, arg ListEvalItemsParams) ([]EvalItem, error) {
	rows, err := q.db.QueryContext(ctx, listEvalItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItem
	for rows.Next() {
		var i EvalItem
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEvalItemsByPrompt = `-- name: SearchEvalItemsByPrompt :many
SELECT id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at FROM eval_items 
WHERE prompt ILIKE '%' || $1 || '%' 
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type SearchEvalItemsByPromptParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchEvalItemsByPrompt(ctx context.Context, arg SearchEvalItemsByPromptParams) ([]EvalItem, error) {
	rows, err := q.db.QueryContext(ctx, searchEvalItemsByPrompt, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EvalItem
	for rows.Next() {
		var i EvalItem
		if err := rows.Scan(
			&i.ID,
			&i.EvalID,
			&i.Prompt,
			pq.Array(&i.Options),
			&i.CorrectIdx,
			&i.Hint,
			&i.Explanation,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvalItem = `-- name: UpdateEvalItem :one
UPDATE eval_items SET
  prompt = COALESCE($2, prompt),
  options = COALESCE($3, options),
  correct_idx = COALESCE($4, correct_idx),
  hint = COALESCE($5, hint),
  explanation = COALESCE($6, explanation),
  metadata = COALESCE($7, metadata),
  updated_at = now()
WHERE eval_items.id = $1
AND eval_items.eval_id IN (SELECT e.id FROM evals e WHERE e.status = 'draft')
RETURNING id, eval_id, prompt, options, correct_idx, hint, explanation, metadata, created_at, updated_at
`

type UpdateEvalItemParams struct {
	ID          uuid.UUID             `json:"id"`
	Prompt      string                `json:"prompt"`
	Options     []string              `json:"options"`
	CorrectIdx  int32                 `json:"correct_idx"`
	Hint        sql.NullString        `json:"hint"`
	Explanation sql.NullString        `json:"explanation"`
	Metadata    pqtype.NullRawMessage `json:"metadata"`
}

func (q *Queries) UpdateEvalItem(ctx context.Context, arg UpdateEvalItemParams) (EvalItem, error) {
	row := q.db.QueryRowContext(ctx, updateEvalItem,
		arg.ID,
		arg.Prompt,
		pq.Array(arg.Options),
		arg.CorrectIdx,
		arg.Hint,
		arg.Explanation,
		arg.Metadata,
	)
	var i EvalItem
	err := row.Scan(
		&i.ID,
		&i.EvalID,
		&i.Prompt,
		pq.Array(&i.Options),
		&i.CorrectIdx,
		&i.Hint,
		&i.Explanation,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
